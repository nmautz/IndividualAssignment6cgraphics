<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>IA6</title>

    <style>

        canvas {
            display: block;
            margin: 10px auto;
            width: 80%;
            height: 80%;
        }

        h1 {
            text-align: center;
        }
    </style>

    <script src="./js/dat.gui.js"></script>
    <script src="./js/three.js"></script>
    <script src="./js/OrbitControls.js"></script>


    <script>

        var state = {};
        var ah = new THREE.AxesHelper(50);

        var cameraParams = {
            near: 1,
            far: 1900,
            fov: 75,                // degrees
            aspectRatio: 700 / 500,   // from dimensions of the canvas, see CSS
            atX: 0,
            atY: 0,
            atZ: 0,
            eyeX: 0,
            eyeY: 20,
            eyeZ: -150,
            upX: 0,
            upY: 1,
            upZ: 0
        };



        // setupCamera() function creates and returns a camera with the desired parameters
        function setupCamera(cameraParameters) {
            // set up an abbreviation 
            var cp = cameraParameters;
            // create an initial camera with the desired shape
            var camera = new THREE.PerspectiveCamera(cp.fov, cp.aspectRatio, cp.near, cp.far);
            // set the camera location and orientation
            camera.position.set(cp.eyeX, cp.eyeY, cp.eyeZ);
            camera.up.set(cp.upX, cp.upY, cp.upZ);
            camera.lookAt(new THREE.Vector3(cp.atX, cp.atY, cp.atZ));
            return camera;
        }

        function redoCamera() {
            scene.remove(camera);
            camera = setupCamera(cameraParams);
            scene.add(camera)
            render();
        }


        function render() {
            // a render function; assume global variables scene, renderer, and camera
            renderer.render(scene, camera);
        }

        function setupCameraControls() {
            var cameraControls = new THREE.OrbitControls(camera, canvas);
            state.cameraControls = cameraControls;
            cameraControls.addEventListener('change', render);
            cameraControls.update();
        }
    </script>

</head>

<body>

    <h1>IA6</h1>
    <p>
    </p>

    <script>



      

        var scene = new THREE.Scene();



        document.addEventListener("DOMContentLoaded", (event) => {
            setupCameraControls();

        });


        let cloud_geom = new THREE.SphereGeometry(1000, 32, 32);
        let cloud_mat = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load('./images/clouds.jpg', ()=>{
                render();
            }),
            side: THREE.DoubleSide,
            opacity: 1.5,
            transparent: true,
            depthWrite: false
        });
        let cloud1_mesh = new THREE.Mesh(cloud_geom, cloud_mat);

        cloud1_mesh.position.set(0, 0, 0);

        scene.add(cloud1_mesh);


        function custom_cube_geom(){
            let geom = new THREE.Geometry();
            let v0 = new THREE.Vector3(0, 0, 0);
            let v1 = new THREE.Vector3(10, 0, 0);
            let v2 = new THREE.Vector3(10, 10, 0);
            let v3 = new THREE.Vector3(0, 10, 0);
            let v4 = new THREE.Vector3(0, 0, 10);
            let v5 = new THREE.Vector3(10, 0, 10);
            let v6 = new THREE.Vector3(10, 10, 10);
            let v7 = new THREE.Vector3(0, 10, 10);

            geom.vertices.push(v0);
            geom.vertices.push(v1);
            geom.vertices.push(v2);
            geom.vertices.push(v3);
            geom.vertices.push(v4);
            geom.vertices.push(v5);
            geom.vertices.push(v6);
            geom.vertices.push(v7);

            let f1 = new THREE.Face3(0, 1, 2);
            let f2 = new THREE.Face3(0, 2, 3);
            let f3 = new THREE.Face3(4, 5, 6);
            let f4 = new THREE.Face3(4, 6, 7);
            let f5 = new THREE.Face3(0, 1, 5);
            let f6 = new THREE.Face3(0, 5, 4);
            let f7 = new THREE.Face3(2, 3, 7);
            let f8 = new THREE.Face3(2, 7, 6);
            let f9 = new THREE.Face3(1, 2, 6);
            let f10 = new THREE.Face3(1, 6, 5);
            let f11 = new THREE.Face3(0, 3, 7);
            let f12 = new THREE.Face3(0, 7, 4);

            geom.faces.push(f1);
            geom.faces.push(f2);
            geom.faces.push(f3);
            geom.faces.push(f4);
            geom.faces.push(f5);
            geom.faces.push(f6);
            geom.faces.push(f7);
            geom.faces.push(f8);
            geom.faces.push(f9);
            geom.faces.push(f10);
            geom.faces.push(f11);
            geom.faces.push(f12);


            return geom;
        }
        let cube_geom = custom_cube_geom();


        function makeTexture(){
          var data = new Uint8Array( 16 * 16 * 3 );
          for ( var i = 0; i < data.length; i += 3 ) {
            var stride = i / 3;
            data[ i ] = stride % 16;
            data[ i + 1 ] = Math.floor( stride / 16 );
            data[ i + 2 ] = 0;
          }
          var texture = new THREE.DataTexture( data, 16, 16, THREE.RGBFormat );
          texture.needsUpdate = true;
          return texture;


        }
        //uv map
        function addTextureCoords(geom) {
            var UVs = [];           // array of face descriptors

            function faceCoords(as, at, bs, bt, cs, ct) {
                // adds the texture coordinates for a single face to the UVs array
                UVs.push([new THREE.Vector2(as, at),
                new THREE.Vector2(bs, bt),
                new THREE.Vector2(cs, ct)]);
            }

            // set up texture coordinates each side of cube
            faceCoords(0, 0, 0, 1, 1, 0);    
            faceCoords(0, 1, 1, 1, 1, 0);    
            faceCoords(0, 1, 1, 0, 0, 0);    
            faceCoords(0, 1, 1, 1, 0.5, 0);  
            faceCoords(0, 1, 1, 1, 0, 0);    
            faceCoords(0, 1, 1, 1, 0, 0);    
            faceCoords(0, 1, 1, 1, 0, 0);    
            faceCoords(0, 1, 1, 1, 0, 0);    
            faceCoords(0, 1, 1, 1, 0, 0);    
            faceCoords(0, 1, 1, 1, 0, 0);    
            faceCoords(0, 1, 1, 1, 0, 0);    
            faceCoords(0, 1, 1, 1, 0, 0);    

            // attach the UVs array to the Geometry
            geom.faceVertexUvs = [UVs];
        }

        addTextureCoords(cube_geom);

        let cube_mat = new THREE.MeshBasicMaterial({
            map: makeTexture(),
            side: THREE.DoubleSide,
            opacity: 1,
            transparent: true,
        });
        let cube_mesh = new THREE.Mesh(cube_geom, cube_mat);
        scene.add(cube_mesh);


        //wall behind the cube
        let wall_geom = new THREE.BoxGeometry(100, 100, 1);
        let wall_mat = new THREE.MeshBasicMaterial({
            color: "grey",
            side: THREE.DoubleSide,
            opacity: 1,
            transparent: true,
        });
        let wall_mesh = new THREE.Mesh(wall_geom, wall_mat);
        wall_mesh.position.z = 50;
        scene.add(wall_mesh);


        let scale_amount = 0.01;

        //increase cube scale
        function increaseScale() {
            cube_mesh.scale.x += scale_amount;
            cube_mesh.scale.y += scale_amount;
            cube_mesh.scale.z += scale_amount;

            //render the scene
        }
        
        //decrease cube scale
        function decreaseScale(){
            cube_mesh.scale.x -= scale_amount;
            cube_mesh.scale.y -= scale_amount;
            cube_mesh.scale.z -= scale_amount;
        }

        //interval to increase scale

        let increase_interval = null;
        let decrease_interval = null;
        let t = 0;
        let max_t = 100;
        function startIncrease(){
            increase_interval = setInterval(()=>{
                increaseScale();
                t++;
                if(t >= max_t){
                    clearInterval(increase_interval);
                    t = 0;
                    startDecrease();
                }
                render()
            }, 10);

        }

        function startDecrease(){
            decrease_interval = setInterval(()=>{
                decreaseScale();
                t++;
                if(t >= max_t){
                    clearInterval(decrease_interval);
                    t = 0;
                    startIncrease();
                }
                render()
            }, 10);

        }

        startIncrease();





        var renderer = new THREE.WebGLRenderer();


        var canvas = renderer.domElement;
        state.renderer = renderer; 
        state.scene = scene; 
        var parent = document.body;
        parent.appendChild(canvas);
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setClearColor(new THREE.Color("grey"), 1); 

        //7. Set up a camera for the scene
        var camera = setupCamera(cameraParams);
        scene.add(camera);


  





    </script>


</body>

</html>